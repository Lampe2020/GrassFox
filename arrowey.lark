_sep{x, sep}:                   ( x ( sep x )* )? // Allow for easy separation of anything
_separated{x, sep}:             sep* _sep{x, sep} sep* // Allow for easy separation of anything, including being padded with sep
_opt_spacepadded{x}:            zero_to_infinite_space x zero_to_infinite_space
_spacepadded{x}:                at_least_one_space x at_least_one_space
start:                          _separated{expression, _opt_spacepadded{expression_separator}}? // Note: the script itself has to end in an `end: ` statement with one argument which can be <> <0> <1> or any integer NUMBER. If it doesn't it will run into the next wall and crash that way.
scope:                          "[" _separated{expression, _opt_spacepadded{expression_separator}}? "]" // enclosing a set of instructions in squared braces sets it into an own scope
error_catching_scope:           "@" scope "_" scope [ "_" scope ] // Any variables defined inside the first or second scope will be available in all subsequent scopes inside the error_catching_scope, except <err>, which is always defined in the second and third scope and contains either the error that occurred in the first scope or <>, overriding the <err> variable if defined in the first or second scope. Any variables defined inside any of the sub scopes in the error_catching_scope are backwards-inherited to the scope containing the error_catching_scope, allowing for trying to import a module and if that fails, importing another or setting an alternative value to the same variable name.
conditional_scope:              "¤(" expression ")" scope ( "_(" expression ")" scope )* ( "_" scope )? // Any variables defined in any of the sub scopes will be backwards-inherited to the parent scope.
looping_scope:                  "&" expression scope
escape_sequence:                "\\" ( "\"" | "'" | "\\" | expression_separator )
unicode_character:              ( "\\x" HEX_DIGIT HEX_DIGIT ) | ( "\\u" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
expression:                     ( format_string | STRING | REGEX | NUMBER | arithmetic_expression | array | class_definition | object | dynamic_obj_prop_access | object_property_reference | inline_if | inversion | logic_operation | assignment | comparison | function_definition | function_call | variable_reference | scope | error_catching_scope | conditional_scope | looping_scope | unary_negative_expression | unary_positive_expression | ( "(" zero_to_infinite_space expression? zero_to_infinite_space ")" ) ) // Can be nested.
assignment:                     type_assignment? ( variable_reference | object_property_reference ) _opt_spacepadded{EQUAL_SIGN} expression
type_assignment:                "(" ( _sep{IDENTIFIER, ";;"} ) type_assignment? ")"
function_call:                  ( ( ( object_property_reference ";;" )? IDENTIFIER) | expression ) ":" ( zero_to_infinite_space [ FLAGLESS_VARIABLE_REFERENCE EQUAL_SIGN ] expression )*
function_definition:            variable_reference ( at_least_one_space ( FLAGLESS_VARIABLE_REFERENCE [ EQUAL_SIGN expression ] ) )* at_least_one_space scope
expression_separator:           _opt_spacepadded{"←"} | _opt_spacepadded{"↓"} | _opt_spacepadded{"↑"} | _opt_spacepadded{"→"}
variable_reference:             type_assignment? [ "g" | "p" ] [ "c" | "i" | "d" ] FLAGLESS_VARIABLE_REFERENCE // Flag meanings: g:global; p:private; c:constant; i:import; d:deletion
object_property_reference:      expression ( ";;" ( FLAGLESS_VARIABLE_REFERENCE | POSITIVE_INTEGER ) )*
FLAGLESS_VARIABLE_REFERENCE:    "<" [ ( "0" | "1" | IDENTIFIER ) ] ">"
IDENTIFIER:                     ( LETTER | "_" )+
ESCAPE_SEQUENCE.1:              "\\" ( "'" | "\"" | "n" | "r" | "d" | "\\" | "$" | "`" | ( DIGIT ) | ( "x" HEX_DIGIT~2 ) | ( "u" HEX_DIGIT~4 ) | ( "s" LETTER+ ";" ) ) // A bunch of escape sequences. Priority 1 (.1 at the end of name) instead of 0.
format_string:                  "`" ( ESCAPE_SEQUENCE | ( "$<(" expression ")>" ) | ( CHARACTER | "'" | "\"" ) )* "`"
STRING:                         ( "\"" ( ESCAPE_SEQUENCE | CHARACTER | "'" | "`" )* "\"" ) | ( "'" ( ESCAPE_SEQUENCE | CHARACTER | "\"" | "`" )* "'" ) // To print out the character used to create the string, use the escape sequence `\ssqu;` for single quote and `\sdqu;` for a double quote. Arrows (that are also separators) in strings can be produced with `\saru;` (↑), `\sard;` (↓), `\sarl;` (←) and `\sarr;` (→). To literally write such an escape sequence, just prefix it with an even amount of backslashes. Escape sequences such as `\n` for newline (UNIX style) and `\r` for carriage return are also valid. `\s[…];` stands for "special character" and is the only escape sequence that has to be terminated with a semicolon.
REGEX:                          ( "g" | "i" | "m" | "s" | "u" | "y" )* "#" STRING // Flags: global, case insensitive, multiline, dotall, unicode, sticky.
CHARACTER:                      /[^"'`\\]/ // Everything that's not ", ', ` or \
object:                         "c"? "{" ( _separated{obj_literal_prop_def, _opt_spacepadded{","}} | ","* )? "}"
class_definition:               "c"? "o" CLASS_NAME_DEF? CLASS_EXTENDS_DEF? scope // A scope with "o" prefix is a nameless class or gets assigned the name of the variable it first lands in. If it has "o{some_name}" prefix it automatically assigns itself to <some_name> and gets assigned that name no matter in what variable it lands. With the "e{some_name}" prefix it extends another class and has to call the "super:" constructor in its "constructor:" method.
CLASS_NAME_DEF:                 "{" IDENTIFIER "}" " "*
CLASS_EXTENDS_DEF:              "e{" IDENTIFIER "}" " "*
obj_literal_prop_def:           (STRING | FLAGLESS_VARIABLE_REFERENCE | IDENTIFIER | POSITIVE_INTEGER) _opt_spacepadded{"="} expression
array:                          "c"? "a{" ( _separated{expression, _opt_spacepadded{","}} | ","* )? "}"
dynamic_obj_prop_access:        expression "{" ( expression | "*" ) "}" // <something_new> = <something_old>{*} clones <something_old>'s contents to <something_new>
inline_if:                      _opt_spacepadded{expression} "?" _opt_spacepadded{expression} "*" _opt_spacepadded{expression} // Also called "ternary"
NUMBER:                         INTEGER_NUMBER | FLOAT_NUMBER
LETTER:                         LOWERCASE_LETTER | UPPERCASE_LETTER
LOWERCASE_LETTER:               "a".."z"
UPPERCASE_LETTER:               "A".."Z"
comparison:                     expression zero_to_infinite_space comparison_operator zero_to_infinite_space expression
comparison_operator:            ( "L" | "l" | "e" | "g" | "G" | "n" | "E" ) EQUAL_SIGN // less than, less than or equal, equal, greater than or equal, greater than, not equal, self-identical (two references to the same object)
HEX_DIGIT:                      DIGIT | "a"i | "b"i | "c"i | "d"i | "e"i | "f"i // LARK string with i behind closing quote: case-insensitive string
DIGIT:                          "0" | NONZERO_DIGIT
INTEGER_NUMBER:                 [ NEGATION ] ( "0" | ( NONZERO_DIGIT POSITIVE_INTEGER* ) )
hex_integer_number:             "0x" HEX_DIGIT+
bin_integer_number:             "0b" ( "1" | "0" ) ( "1" | "0" )*
FLOAT_NUMBER:                   ( INTEGER_NUMBER "." POSITIVE_INTEGER ) | "NaN"
NONZERO_DIGIT:                  /[1-9]/
at_least_one_space:             " "+
zero_to_infinite_space:         " "*
NEGATION:                       "-"
unary_positive_expression:      "+" expression // This is there to enable chaining of "+" operator but is executionally ignored
unary_negative_expression:      "-" expression // This is there to enable chaining of "-" operator and is functionally the same as "expression•-1"
EQUAL_SIGN:                     "="
POWER_OPERATOR:                 "^"
DOT_OPERATOR:                   "•" | ":" | "%" // times, divided by, modulo
DASH_OPERATOR:                  "+" | NEGATION // plus, minus
arithmatic_operator:            DOT_OPERATOR | DASH_OPERATOR
POSITIVE_INTEGER:               "0" | ( NONZERO_DIGIT DIGIT* ) // zero or any whole NUMBER not starting with zero
logic_operation:                ( expression zero_to_infinite_space logic_operator zero_to_infinite_space expression )
inversion:                      ( "n" ) "^" zero_to_infinite_space expression // Technically also a logic operation, I just count it as an own thing.
logic_operator:                 ( "a" | "o" | "x" | "l" | "r" ) "^" // and, or, xor, lshift, rshift
arithmetic_expression:          powerarithmetic_expression | dotarithmetic_expression | dasharithmetic_expression
powerarithmetic_expression:     expression POWER_OPERATOR expression
dotarithmetic_expression:       expression DOT_OPERATOR expression
dasharithmetic_expression:      expression DASH_OPERATOR expression
